<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>reporte</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="REPORTE_files/libs/clipboard/clipboard.min.js"></script>
<script src="REPORTE_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="REPORTE_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="REPORTE_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="REPORTE_files/libs/quarto-html/popper.min.js"></script>
<script src="REPORTE_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="REPORTE_files/libs/quarto-html/anchor.min.js"></script>
<link href="REPORTE_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="REPORTE_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="REPORTE_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="REPORTE_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="REPORTE_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="differential-expression-analysis-in-mouse" class="level1">
<h1>Differential Expression Analysis in Mouse</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this work, a differential expression analysis was performed using RNA-seq data from a murine model. The objective was to identify differentially expressed genes between the selected experimental conditions and to understand the associated biological changes.</p>
</section>
<section id="dataset-selection" class="level2">
<h2 class="anchored" data-anchor-id="dataset-selection">Dataset Selection</h2>
<p>The project SRP131263 was selected because it contains approximately 30 samples. This provides sufficient replication to obtain statistically robust results without making the analysis unnecessarily complex.</p>
<p>The dataset was selected based on:</p>
<ul>
<li>Sufficient number of samples<br>
</li>
<li>Good balance between conditions<br>
</li>
<li>Publicly available and properly annotated data</li>
</ul>
</section>
<section id="data-preparation" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation">Data Preparation</h2>
<p>First, the data were loaded using R tools designed for transcriptomic data handling. The following steps were then performed:</p>
<ul>
<li>Inspection of the count matrix<br>
</li>
<li>Verification of sample metadata<br>
</li>
<li>Filtering of low-expression genes<br>
</li>
<li>Data normalization</li>
</ul>
<p>These steps were necessary to ensure valid comparisons between conditions and to reduce potential technical biases.</p>
</section>
<section id="differential-expression-analysis" class="level2">
<h2 class="anchored" data-anchor-id="differential-expression-analysis">Differential Expression Analysis</h2>
<p>An appropriate statistical model for count data was applied. The analysis allowed the estimation of:</p>
<ul>
<li>Expression changes (log2 Fold Change)<br>
</li>
<li>Adjusted statistical significance<br>
</li>
<li>Upregulated and downregulated genes</li>
</ul>
<p>A significance threshold based on adjusted p-values was used to control for multiple testing.</p>
</section>
<section id="main-results" class="level2">
<h2 class="anchored" data-anchor-id="main-results">Main Results</h2>
<p>The analysis identified a set of differentially expressed genes between the evaluated conditions.</p>
<p>The results showed:</p>
<ul>
<li>Significantly upregulated genes<br>
</li>
<li>Significantly downregulated genes<br>
</li>
<li>Consistency across biological replicates</li>
</ul>
<p>These findings suggest biological changes associated with the experimental condition under study.</p>
</section>
<section id="workflow" class="level2">
<h2 class="anchored" data-anchor-id="workflow">Workflow</h2>
<p>The analysis was organized into three main stages, each implemented in an independent script to maintain clarity and methodological order.</p>
<section id="data-retrieval-and-initial-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-retrieval-and-initial-preparation">1. Data Retrieval and Initial Preparation</h3>
<p>In the first script, the recount3 library was used to explore available mouse projects and select project SRP131263. The selection was based on the number of samples and its suitability for differential expression analysis.</p>
<p>The dataset was downloaded and a RangedSummarizedExperiment object was constructed, containing both the count matrix and annotation information. Gene-level read counts were computed, and SRA attributes were expanded to incorporate relevant metadata into the object.</p>
<p>Finally, two versions of the object were saved: a raw version and a processed version. This ensures traceability between the original downloaded data and the data prepared for downstream analysis.</p>
</section>
<section id="quality-control-and-differential-expression-analysis" class="level3">
<h3 class="anchored" data-anchor-id="quality-control-and-differential-expression-analysis">2. Quality Control and Differential Expression Analysis</h3>
<p>In the second script, the processed object was loaded and quality assessment was performed. The proportion of reads assigned to genes was calculated to verify that no extreme outliers or evident quality issues were present.</p>
<p>Metadata were then explored to evaluate the distribution of genotypes and cell types. Based on this exploration, the analysis was restricted to a single cell type (Act_CD4) in order to avoid potential confounding effects derived from different Cre systems.</p>
<p>The dataset was filtered by removing low-expression genes, requiring a minimum count threshold in at least three samples. This reduces statistical noise and improves model stability.</p>
<p>A DESeq2 object was then constructed, defining the experimental design based on genotype. The wild-type genotype was set as the reference level to ensure biologically coherent interpretation of expression changes.</p>
<p>The DESeq2 statistical model was executed to estimate differential expression. The resulting output included log2 Fold Changes and adjusted p-values. Both the model object and the results were saved for downstream visualization and interpretation.</p>
</section>
<section id="visualization-and-interpretation-of-results" class="level3">
<h3 class="anchored" data-anchor-id="visualization-and-interpretation-of-results">3. Visualization and Interpretation of Results</h3>
<p>In the third script, the model outputs were loaded and a variance stabilizing transformation was applied to facilitate visualization of global expression patterns.</p>
<p>Several key plots were generated:</p>
<ul>
<li>Principal Component Analysis (PCA) to assess separation between genotypes<br>
</li>
<li>MA plot to visualize expression changes relative to mean expression<br>
</li>
<li>Volcano plot to identify significantly differentially expressed genes based on combined statistical and fold change thresholds<br>
</li>
<li>Heatmap of the top 30 most significantly differentially expressed genes, using gene-wise scaled expression values to highlight relative patterns across samples</li>
</ul>
<p>All figures were exported as independent files to visually document the results of the analysis.</p>
<p>The complete workflow follows a modular structure that clearly separates data acquisition, statistical modeling, and visualization. This organization enhances reproducibility, biological interpretability, and flexibility for modifying individual stages without affecting the overall analysis.</p>
</section>
<section id="principal-component-analysis-pca" class="level3">
<h3 class="anchored" data-anchor-id="principal-component-analysis-pca">Principal Component Analysis (PCA)</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/PCA_plot.png" class="img-fluid figure-img"></p>
<figcaption>PCA</figcaption>
</figure>
</div>
<p>The PCA plot shows a clear separation between genotypes along PC1, which explains 95% of the total variance. This indicates that genotype is the main source of variation in the dataset. Samples cluster tightly within each group, suggesting good reproducibility among biological replicates.</p>
<p>PC2 explains only 2% of the variance and does not contribute substantially to group separation, further supporting that the primary transcriptional differences are driven by genotype rather than technical variability or noise.</p>
<p>Overall, the strong separation along PC1 indicates a robust and consistent transcriptional effect associated with the Bap1 genotype.</p>
</section>
<section id="ma-plot" class="level3">
<h3 class="anchored" data-anchor-id="ma-plot">MA Plot</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/MA_plot.png" class="img-fluid figure-img"></p>
<figcaption>MA</figcaption>
</figure>
</div>
<p>The MA plot displays the log2 fold change as a function of mean normalized expression. Most genes cluster around log2 fold change values near zero, indicating that the majority of genes are not differentially expressed between genotypes.</p>
<p>However, a distinct subset of genes shows substantial positive or negative fold changes, particularly at moderate expression levels. The distribution appears symmetric, suggesting both upregulation and downregulation events.</p>
<p>The spread of points is wider at lower expression levels, which is expected due to increased variance in low-count genes. At higher expression levels, fold changes appear more stable, reflecting improved statistical confidence in well-expressed genes.</p>
</section>
<section id="volcano-plot" class="level3">
<h3 class="anchored" data-anchor-id="volcano-plot">Volcano Plot</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/Volcano_plot.png" class="img-fluid figure-img"></p>
<figcaption>Volcano</figcaption>
</figure>
</div>
<p>The volcano plot integrates both statistical significance and magnitude of change. Genes meeting the significance threshold (adjusted p-value &lt; 0.05 and |log2FC| &gt; 1) are clearly separated from non-significant genes.</p>
<p>A considerable number of genes surpass both thresholds, indicating a strong transcriptional response associated with genotype. Significant genes are distributed on both sides of the plot, demonstrating the presence of both upregulated and downregulated genes.</p>
<p>The clear vertical and horizontal separation suggests that the identified differentially expressed genes are not only statistically significant but also biologically meaningful in magnitude.</p>
</section>
<section id="heatmap-of-top-30-differentially-expressed-genes" class="level3">
<h3 class="anchored" data-anchor-id="heatmap-of-top-30-differentially-expressed-genes">Heatmap of Top 30 Differentially Expressed Genes</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plots/Heatmap_top30.png" class="img-fluid figure-img"></p>
<figcaption>HeatMap</figcaption>
</figure>
</div>
<p>The heatmap of the top 30 most significantly differentially expressed genes shows clear clustering of samples according to genotype. Samples group into two distinct clusters, corresponding to wild-type and mutant conditions.</p>
<p>Gene expression patterns display strong contrast between groups, with consistent upregulation in one genotype and downregulation in the other. The consistency across biological replicates indicates high reproducibility of the transcriptional differences.</p>
<p>The hierarchical clustering dendrogram further confirms that genotype is the dominant factor structuring the data. These results reinforce the findings observed in the PCA and volcano plots, demonstrating robust and coordinated gene expression changes associated with Bap1 status.</p>
</section>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>This study presents a structured and reproducible differential expression analysis of RNA-seq data from a murine model. By applying an appropriate statistical framework for count data and implementing careful preprocessing steps — including gene filtering, normalization, and controlled experimental design — reliable transcriptional differences between genotypes were identified.</p>
<p>The consistency observed across multiple visualization strategies (PCA, MA plot, volcano plot, and heatmap) supports the robustness of the results. In particular, the strong separation in PCA and the clear clustering pattern in the heatmap indicate that genotype represents the dominant source of transcriptional variation in Act_CD4 cells.</p>
<p>The identification of both upregulated and downregulated genes suggests that the experimental condition induces coordinated regulatory changes rather than isolated transcriptional effects. These findings provide a foundation for further biological interpretation and downstream functional analyses aimed at understanding the molecular mechanisms associated with Bap1 status.</p>
<p>Overall, the modular workflow implemented in this project ensures transparency, reproducibility, and flexibility, allowing the analysis to be extended or adapted to additional datasets or biological questions in future studies.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>